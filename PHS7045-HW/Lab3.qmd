---
title: "Lab3"
format: pdf
editor: visual
author: "Yidan"
---

## 

```{r}
simulation_rar <- function(prob) {
  # Build an empty matrix that allow the maximum capacitity to store the outcome of trial
  result <- matrix(nrow = 228, ncol = 4)  
  colnames(result) <- c(paste0("t", 0:3))
  
  #Always fill the first 10 rows with binomial result using defined probability
  result[1:10, ] <- sapply(1:4, function(i) rbinom(10, 1, prob = prob[i]))
  
  #Countinue to allocate and generate the outcome until N=228
  while(sum(!is.na(result)) < 228) {
    nt <- colSums(!is.na(result))
    yt <- colSums(result, na.rm = TRUE)
    posterior <- sapply(1:4, function(i) rbeta(n = 1000, shape1 = 0.35 + yt[i], shape2 = 0.65 + nt[i] - yt[i]))
    colnames(posterior) <- c(paste0("t", 0:3))
    
    V <- sapply(1:4, function(i) mean(apply(posterior, 1, function(row) row[i] == max(row))))
    #Adjust V_0
    V[1] <- min(sum(sapply(2:4, function(i) V[i] * ((nt[i] + 1) / (nt[1] + 1)))), max(V[2:4]))
    V <- V / sum(V)  # Normalize V
    
    #Since the last group don't have 40 subjects (maybe only 28), so need to make sure don't exceed the allocation
    #How many values are still needed to reach exactly 228 subject 
    needed_non_na <- 228 - sum(!is.na(result))
    # Find the allocation to treatment arm based on V
    allocation <- rmultinom(n = 1, size = min(40, needed_non_na), prob = V)
    
    # Generate new outcome for this group of participants 
    replacement_values <- lapply(1:4, function(i) rbinom(n = allocation[i], 1, prob = prob[i]))
    
    # Replace NA values in the result matrix to the result for the next group column by column
    for (i in 1:4) {
      na_indices <- which(is.na(result[, i]))  # Get NA indices for the column
      replacement <- replacement_values[[i]] # Match with the outcome vector that ready to be replaced
      
      # Ensure only replace as many NAs as needed and not exceed 228
      if (length(na_indices) > 0) {
        # Find how many more values we can replace in this column
        num_to_replace <- min(length(replacement), length(na_indices), needed_non_na)
        
        # Perform the replacement
        result[na_indices[1:num_to_replace], i] <- replacement[1:num_to_replace]
        
        # Update the count of needed non-NA values after replacement
        needed_non_na <- 228 - sum(!is.na(result))
      }
    }
  }
  n_success <-colSums(result,na.rm = TRUE)
  n_enroll <- colSums(!is.na(result))
  post_final <- sapply(1:4, function(i) rbeta(n = 5000, shape1 = 0.35 + n_success[i], shape2 = 0.65 + n_enroll[i] - n_success[i]))
  better <- apply(posterior[, 1:4], 2, function(x) mean(x > posterior[, 1]))
  best <- sapply(1:4, function(i) mean(apply(posterior, 1, function(row) row[i] == max(row))))
  return(list(better = better, best = best))
}  
  
simulation_rar(prob=rep(0.35,4))
```

```{r}
simulation_er <- function(prob) {
  # Define the ratio (2:1:1:1)
  ratio <- c(2, 1, 1, 1)
  
  # Calculate the number of participants for each arm based on the ratio
  group_sizes <- floor(228 * ratio / sum(ratio))
 
   # Determine the number of leftover participants
  leftover <- 228 - sum(group_sizes)
  
  # If there are any leftover participants (due to rounding), assign them to random arm
  if (leftover > 0) {
    random_arms <- sample(1:4, leftover, replace = FALSE)  # Randomly select arms for the leftovers
    for (arm in random_arms) {
      group_sizes[arm] <- group_sizes[arm] + 1
    }
  }
  
  # Generate binomial results for each arm using sapply
  results <- sapply(1:4, function(i) rbinom(group_sizes[i], size = 1, prob = prob[i]))
  
  # Combine the results into a data frame, filling shorter columns with NA
  result_er <- as.data.frame(sapply(1:4, function(i) {
    c(results[[i]], rep(NA, max(group_sizes) - length(results[[i]])))
  }))
  
  n_success <-colSums(result_er,na.rm = TRUE)
  n_enroll <- colSums(!is.na(result_er))
  posterior_er <- sapply(1:4, function(i) rbeta(n = 1000, shape1 = 0.35 + n_success[i], shape2 = 0.65 + n_enroll[i] - n_success[i]))
  prob <- apply(posterior_er[, 1:4], 2, function(x) mean(x > posterior_er[, 1]))
  better <- apply(posterior_er[, 1:4], 2, function(x) mean(x > posterior_er[, 1]))
  best <- sapply(1:4, function(i) mean(apply(posterior_er, 1, function(row) row[i] == max(row))))
  return(list(better = better, best = best))
}
simulation_er(prob=rep(0.35,4))

```
